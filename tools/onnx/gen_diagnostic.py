#!/usr/bin/env python3

""" Generates PyTorch ONNX Export Diagnostic rules for C++, Python and documentations.
The rules are defined in torch/onnx/diagnostic/rules.yaml.

Usage:

python -m tools.onnx.gen_diagnostic \
    torch/onnx/diagnostic/rules.yaml \
    torch/onnx/diagnostic/generated \
    torch/csrc/onnx/diagnostic/generated \
    torch/docs/source
"""

import argparse
import os
import subprocess
import textwrap
from typing import Any, Mapping, Sequence

import yaml

from torchgen import utils as torchgen_utils

_PY_RULES_COMMENT = """\
Diagnostic rules for PyTorch ONNX export.

This file is generated by gen_diagnostic.py. Do not edit directly.
See tools/onnx/gen_diagnostic.py for more information.
"""

_PY_RULE_TEMPLATE = """\
{0} = diagnostic.Rule(**{1})
\"\"\"{2}\"\"\"
"""

_CPP_RULE_TEMPLATE = """\
/**
 * @brief {1}
 */
{0},
"""


def gen_diagnostic_python(
    rules: Sequence[Mapping[str, Any]], out_py_dir: str, template_dir: str
) -> None:
    def format_rule(rule: Mapping[str, Any]) -> str:
        name = rule["name"]
        short_description = rule["short_description"]["text"]
        return _PY_RULE_TEMPLATE.format(name, rule, short_description)

    rule_lines = [format_rule(rule) for rule in rules]

    fm = torchgen_utils.FileManager(
        install_dir=out_py_dir, template_dir=template_dir, dry_run=False
    )
    fm.write_with_template(
        "rules.py",
        "rules.py.in",
        lambda: {
            "generated_comment": _PY_RULES_COMMENT,
            "rules": textwrap.indent("\n".join(rule_lines), " " * 4),
        },
    )
    _lint_file(os.path.join(out_py_dir, "rules.py"))


def gen_diagnostic_cpp(
    rules: Sequence[Mapping[str, Any]], out_cpp_dir: str, template_dir: str
) -> None:
    def format_rule(rule: Mapping[str, Any]) -> str:
        return _CPP_RULE_TEMPLATE.format(
            rule["name"],
            rule["short_description"]["text"],
        )

    rule_lines = [format_rule(rule) for rule in rules]
    rule_names = [f'"{rule["name"]}",' for rule in rules]

    fm = torchgen_utils.FileManager(
        install_dir=out_cpp_dir, template_dir=template_dir, dry_run=False
    )
    fm.write_with_template(
        "rules.h",
        "rules.h.in",
        lambda: {
            "generated_comment": f"@generated from {fm.template_dir}/rules.h.in",
            "rules": textwrap.indent("\n".join(rule_lines), " " * 2),
            "rule_names": textwrap.indent("\n".join(rule_names), " " * 4),
        },
    )
    _lint_file(os.path.join(out_cpp_dir, "rules.h"))


def gen_diagnostic_docs(out_docs_dir: str) -> None:
    # TODO
    pass


def _lint_file(file_path: str) -> None:
    p = subprocess.Popen(["lintrunner", "-a", file_path])
    p.wait()


def gen_diagnostic(
    rules_path: str,
    out_py_dir: str,
    out_cpp_dir: str,
    out_docs_dir: str,
) -> None:

    with open(rules_path, "r") as f:
        rules = yaml.load(f, Loader=torchgen_utils.YamlLoader)

    template_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "templates")

    # TODO: run lintrunner for generated files

    gen_diagnostic_python(
        rules,
        out_py_dir,
        template_dir,
    )

    gen_diagnostic_cpp(
        rules,
        out_cpp_dir,
        template_dir,
    )

    # gen_diagnostic_docs(out_docs_dir)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate ONNX diagnostic files")
    parser.add_argument("rules_path", metavar="RULES", help="path to rules.yaml")
    parser.add_argument(
        "out_py_dir",
        metavar="OUT_PY",
        help="path to output directory for Python",
    )
    parser.add_argument(
        "out_cpp_dir",
        metavar="OUT_CPP",
        help="path to output directory for C++",
    )
    parser.add_argument(
        "out_docs_dir",
        metavar="OUT_DOCS",
        help="path to output directory for docs",
    )
    args = parser.parse_args()
    gen_diagnostic(
        args.rules_path,
        args.out_py_dir,
        args.out_cpp_dir,
        args.out_docs_dir,
    )


if __name__ == "__main__":
    main()
